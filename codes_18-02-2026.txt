In a futuristic smart city, a central power grid is connected to a line of N solar 
panels (indexed 1 to N). Each panel generates a specific amount of wattage. 
Because weather conditions change rapidly, the wattage of these panels fluctuates. 
The grid controller needs a high-performance system to monitor these changes 
and calculate energy yields in real-time.

You must support two operations:
1. Point Update (1 i v): Panel i changes its output. Add 'v' to its current wattage.
   (Note: v can be negative if it gets cloudy).
2. Range Query (2 L R): Calculate the total power produced by panels from 
   index L to index R (inclusive).
   
Input Format
------------
Line 1: An integer N, representing the total number of solar panels.
Line 2: N space-separated integers, representing the initial wattage of panels from index 1 to N.
Line 3: An integer Q, the total number of operations to be performed.
Next Q Lines: Three space-separated integers per line:
	1 i v: Update Operation — Add v to the wattage of panel i.
	2 L R: Query Operation — Calculate the total sum of wattage from panel L to panel R 
	(inclusive).
	
Output Format:
--------------
For every Type 2 (Query) operation, output a single integer representing the total wattage in the 
specified range on a new line.


Sample Input:
-------------
5
1 2 3 4 5
3
2 1 3
1 2 10
2 1 3

Sample Output:
--------------
6
16

Explanation
-----------
Let's track the "Solar Grid" step by step:
Initial State:
Panels: [1, 2, 3, 4, 5]

Operation 1:
    2 1 3 (Range Sum Query)
    We need the sum from index 1 to 3.
    Calculation: 1 + 2 + 3 = 6.
    Output: 6

Operation 2:
    1 2 10 (Point Update)
    We add 10 to the panel at index 2.
    Old value was 2, new value is 2 + 10 = 12.
    Updated Panels: [1, 12, 3, 4, 5]

Operation 3: 
    2 1 3 (Range Sum Query)
    We need the sum from index 1 to 3 again.
    Calculation: 1 + 12 + 3 = 16.
    Output: 16


CONSTRAINTS
-----------
 1 <= N, Q <= 10^5
 -10^4 <= initial_wattage, v <= 10^4
 1 <= i, L, R <= N

code:

import java.util.*;

class Solution {
    int[] nums;
    int[] BIT;
    int n;
    
    public FenWickTree(int[] nums) {
        this.nums = nums;
        n = nums.length;
        BIT = new int[n + 1];

        for (int i = 0; i < n; i++)
            init(i, nums[i]);
    }
    public void init(int i, int val) {
        i++;
        while (i <= n) {
            BIT[i] += val;
            i += (i & -i);
        }
    }
    void update(int i, int v) {
        nums[i] += v;
        init(i, v);
    }
    public int getSum(int i) {
        int sum = 0;
        i++;
        while (i > 0) {
            sum += BIT[i];
            i -= (i & -i);
        }
        return sum;
    }
    public int sumRange(int i, int j) {
        return getSum(j) - getSum(i - 1);
    }
    public static void main(String args[]) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++)
            nums[i] = scan.nextInt();
        FenWickTree ft = new FenWickTree(nums);
        int Q = scan.nextInt();
        for (int q = 0; q < Q; q++) {
            int type = scan.nextInt();
            if (type == 1) {
                int ind = scan.nextInt();
                int v = scan.nextInt();
                ft.update(ind - 1, v);
            } else {
                int L = scan.nextInt();
                int R = scan.nextInt();
                System.out.println(ft.sumRange(L - 1, R - 1));
            }
        }
        scan.close();
    }
}